# Monster
#include &lt;Array.au3> #include &lt;String.au3>  Example()  Func Example()     Local $sStr = "" ; Monster string for testing     For $i = 1 To 10000000         $sStr &amp;= Chr(Random(1, 255, 1))     Next      MsgBox(0, "First 300 out of 10000000 Chracters", StringLeft($sStr, 300))     Local $sDelim = _GetDelim($sStr)     If Not @error Then         ConsoleWrite("&lt;---| " &amp; $sDelim &amp; " |--->" &amp; @LF)     Else         ConsoleWrite("&lt;---| FAILED |--->" &amp; @LF)     EndIf EndFunc  Func _GetDelim($sTest)     If Not IsString($sTest) Then Return SetError(1, 0, "") ; Invalid Input String.      Local $aAscII[31], $sDelim ; Using Control Characters only.     ; First try one character     For $i = 1 To 31         $sDelim = Chr($i)         If Not StringInStr($sTest, $sDelim, 1) Then             Return $sDelim         Else             $aAscII[$i - 1] = $sDelim ; Needed for the next stage.         EndIf     Next      ; That failed - so we try two characters.     Local $aDoubleChar = _ArrayCombinations($aAscII, 2, "")     For $i = 1 To $aDoubleChar[0]         $sDelim = $aDoubleChar[$i]         If Not StringInStr($sTest, $sDelim, 1) Then Return $sDelim     Next      ; That failed - so we try the reverse patterns.     ReDim $aDoubleChar[931]     $aDoubleChar[0] = 930      For $i = 466 To $aDoubleChar[0]         $sDelim = _StringReverse($aDoubleChar[$i -465])         If Not StringInStr($sTest, $sDelim, 1) Then             Return $sDelim         Else             $aDoubleChar[$i] = $sDelim ; Needed for the next stage.         EndIf     Next      ; That failed - so we try three characters.     For $i = 1 To $aDoubleChar[0]         For $j = 0 To 30             $sDelim = $aDoubleChar[$i] &amp; $aAscII[$j]             If Not StringInStr($sTest, $sDelim, 1) Then Return $sDelim         Next     Next      ; That failed - so we try four characters.     For $i = 1 To $aDoubleChar[0]         For $j = 1 To $aDoubleChar[0]             $sDelim = $aDoubleChar[$i] &amp; $aDoubleChar[$j]             If Not StringInStr($sTest, $sDelim, 1) Then Return $sDelim         Next     Next      ; That failed - so we try five characters.     For $i = 1 To $aDoubleChar[0]         For $j = 1 To $aDoubleChar[0]             For $k = 0 To 30                 $sDelim = $aDoubleChar[$i] &amp; $aDoubleChar[$j] &amp; $aAscII[$k]                 If Not StringInStr($sTest, $sDelim, 1) Then Return $sDelim             Next         Next     Next      ; Here we could also try six characters followed by seven etc.     Return SetError (2, 0, "") ; No suitable delimiter found. EndFunc
